\hypertarget{classPipeline}{}\doxysection{Pipeline Class Reference}
\label{classPipeline}\index{Pipeline@{Pipeline}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classPipeline_a882528d2d5712d429f33329dbf97b0dd}{Pipeline}} (std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classMuxer}{Muxer}} $>$ muxer, bool async=false)
\item 
\mbox{\Hypertarget{classPipeline_acdbef56529368f248e7290f13e8f9940}\label{classPipeline_acdbef56529368f248e7290f13e8f9940}} 
{\bfseries Pipeline} (const \mbox{\hyperlink{classPipeline}{Pipeline}} \&)=delete
\item 
\mbox{\Hypertarget{classPipeline_a5bd72869a5c4d5a9a02a67892be2e1b3}\label{classPipeline_a5bd72869a5c4d5a9a02a67892be2e1b3}} 
\mbox{\hyperlink{classPipeline}{Pipeline}} \& {\bfseries operator=} (const \mbox{\hyperlink{classPipeline}{Pipeline}} \&)=delete
\item 
void \mbox{\hyperlink{classPipeline_abdb81129dd9b6fc8b6db16ecba3c0a98}{init\+Video}} (const \mbox{\hyperlink{classDemuxer}{Demuxer}} \&demuxer, AVCodec\+ID codec\+\_\+id, AVPixel\+Format pix\+\_\+fmt, const \mbox{\hyperlink{classVideoParameters}{Video\+Parameters}} \&video\+\_\+params)
\item 
void \mbox{\hyperlink{classPipeline_a91369041b8817898d3d3752e497564f2}{init\+Audio}} (const \mbox{\hyperlink{classDemuxer}{Demuxer}} \&demuxer, AVCodec\+ID codec\+\_\+id)
\item 
void \mbox{\hyperlink{classPipeline_ab28f046f571aad557913004be339748d}{feed}} (av\+::\+Packet\+UPtr packet, av\+::\+Media\+Type packet\+\_\+type)
\item 
void \mbox{\hyperlink{classPipeline_ad0d10bdda090c0f7d8e0ce79653f9f23}{flush}} ()
\item 
void \mbox{\hyperlink{classPipeline_a219c911a44e34564f4a0fbe28e049412}{print\+Info}} () const
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


Definition at line \mbox{\hyperlink{pipeline_8h_source_l00017}{17}} of file \mbox{\hyperlink{pipeline_8h_source}{pipeline.\+h}}.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classPipeline_a882528d2d5712d429f33329dbf97b0dd}\label{classPipeline_a882528d2d5712d429f33329dbf97b0dd}} 
\index{Pipeline@{Pipeline}!Pipeline@{Pipeline}}
\index{Pipeline@{Pipeline}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{Pipeline()}{Pipeline()}}
{\footnotesize\ttfamily Pipeline\+::\+Pipeline (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classMuxer}{Muxer}} $>$}]{muxer,  }\item[{bool}]{async = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

Create a new \mbox{\hyperlink{classPipeline}{Pipeline}} for processing packets 
\begin{DoxyParams}{Parameters}
{\em muxer} & the muxer to send the processed packets to (WARNING\+: the muxer must not be opened until the \mbox{\hyperlink{classPipeline}{Pipeline}} initialization is complete) \\
\hline
{\em async} & whether the pipeline should use background threads to handle the processing (recommended when a single demuxer will provide both video and audio packets) \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00012}{12}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00012                                                          : muxer\_(std::move(muxer)), async\_(async) \{}
\DoxyCodeLine{00013     \textcolor{keywordflow}{if} (!muxer\_) throwError(\textcolor{stringliteral}{"{}received Muxer is null"{}});}
\DoxyCodeLine{00014     \textcolor{keywordflow}{if} (async\_) stopped\_ = \textcolor{keyword}{false};}
\DoxyCodeLine{00015 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classPipeline_a527044d53a20f851d0579fbf313a2dec}\label{classPipeline_a527044d53a20f851d0579fbf313a2dec}} 
\index{Pipeline@{Pipeline}!````~Pipeline@{$\sim$Pipeline}}
\index{````~Pipeline@{$\sim$Pipeline}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{$\sim$Pipeline()}{~Pipeline()}}
{\footnotesize\ttfamily Pipeline\+::$\sim$\+Pipeline (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00017}{17}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00017                     \{}
\DoxyCodeLine{00018     \textcolor{keywordflow}{if} (async\_) stopProcessors();}
\DoxyCodeLine{00019 \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classPipeline_ab28f046f571aad557913004be339748d}\label{classPipeline_ab28f046f571aad557913004be339748d}} 
\index{Pipeline@{Pipeline}!feed@{feed}}
\index{feed@{feed}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{feed()}{feed()}}
{\footnotesize\ttfamily void Pipeline\+::feed (\begin{DoxyParamCaption}\item[{av\+::\+Packet\+UPtr}]{packet,  }\item[{av\+::\+Media\+Type}]{packet\+\_\+type }\end{DoxyParamCaption})}

Send the packet to the processing chain corresponding to its type. If \textquotesingle{}async\textquotesingle{} was set to true when building the \mbox{\hyperlink{classPipeline}{Pipeline}}, the background threads will handle the packet processing and this function will return immediately, otherwise the processing will be handled in a synchronous way and this function will return only once it\textquotesingle{}s completed 
\begin{DoxyParams}{Parameters}
{\em packet} & the packet to send to che processing chain (if NULL, an exception will be thrown) \\
\hline
{\em packet\+\_\+type} & the type of the packet to process \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00170}{170}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00170                                                                 \{}
\DoxyCodeLine{00171     \textcolor{keywordflow}{if} (!packet) throwError(\textcolor{stringliteral}{"{}received packet is null"{}});}
\DoxyCodeLine{00172     \textcolor{keywordflow}{if} (!av::validMediaType(packet\_type)) throwError(\textcolor{stringliteral}{"{}failed to take packet (media type is invalid)"{}});}
\DoxyCodeLine{00173     \textcolor{keywordflow}{if} (!managed\_types\_[packet\_type]) throwError(\textcolor{stringliteral}{"{}No pipeline corresponding to received packet type"{}});}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175     \textcolor{keywordflow}{if} (async\_) \{}
\DoxyCodeLine{00176         std::unique\_lock ul\{m\_\};}
\DoxyCodeLine{00177         \textcolor{keywordflow}{if} (stopped\_) throwError(\textcolor{stringliteral}{"{}already stopped"{}});}
\DoxyCodeLine{00178         checkExceptions();}
\DoxyCodeLine{00179         \textcolor{keywordflow}{if} (!packets\_[packet\_type]) \{  \textcolor{comment}{// if previous packet has been fully processed}}
\DoxyCodeLine{00180             packets\_[packet\_type] = std::move(packet);}
\DoxyCodeLine{00181             packets\_cv\_[packet\_type].notify\_all();}
\DoxyCodeLine{00182         \}}
\DoxyCodeLine{00183     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00184         processPacket(packet.get(), packet\_type);}
\DoxyCodeLine{00185     \}}
\DoxyCodeLine{00186 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classPipeline_ad0d10bdda090c0f7d8e0ce79653f9f23}\label{classPipeline_ad0d10bdda090c0f7d8e0ce79653f9f23}} 
\index{Pipeline@{Pipeline}!flush@{flush}}
\index{flush@{flush}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{flush()}{flush()}}
{\footnotesize\ttfamily void Pipeline\+::flush (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Flush the processing pipelines. If \textquotesingle{}async\textquotesingle{} was set to true when building the \mbox{\hyperlink{classPipeline}{Pipeline}}, the background threads will be completely stopped before the actual flushing. WARNING\+: this function must be called BEFORE closing the output file with \mbox{\hyperlink{classMuxer_a11f0ea0fda943312eb42a7f6701dd08e}{Muxer\+::close\+File}}, otherwise some packets/frames will be left in the processing structures and eventual background workers won\textquotesingle{}t be able to write the packets to he output file, throwing an exception 

Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00193}{193}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00193                      \{}
\DoxyCodeLine{00194     \textcolor{keywordflow}{if} (async\_) \{}
\DoxyCodeLine{00195         \textcolor{comment}{/* stop all threads working on the pipelines */}}
\DoxyCodeLine{00196         stopProcessors();}
\DoxyCodeLine{00197         checkExceptions();}
\DoxyCodeLine{00198     \}}
\DoxyCodeLine{00199 }
\DoxyCodeLine{00200     \textcolor{comment}{/* flush the pipelines */}}
\DoxyCodeLine{00201     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} type : av::validMediaTypes) \{}
\DoxyCodeLine{00202         \textcolor{keywordflow}{if} (managed\_types\_[type]) flushPipeline(type);}
\DoxyCodeLine{00203     \}}
\DoxyCodeLine{00204 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classPipeline_a91369041b8817898d3d3752e497564f2}\label{classPipeline_a91369041b8817898d3d3752e497564f2}} 
\index{Pipeline@{Pipeline}!initAudio@{initAudio}}
\index{initAudio@{initAudio}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{initAudio()}{initAudio()}}
{\footnotesize\ttfamily void Pipeline\+::init\+Audio (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classDemuxer}{Demuxer}} \&}]{demuxer,  }\item[{AVCodec\+ID}]{codec\+\_\+id }\end{DoxyParamCaption})}

Initialize the audio processing, by creating the corresponding decoder, converter and encoder 
\begin{DoxyParams}{Parameters}
{\em demuxer} & the demuxer containing the input stream of packets \\
\hline
{\em codec\+\_\+id} & the ID of the codec to use for the output audio \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00099}{99}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00099                                                                    \{}
\DoxyCodeLine{00100     \textcolor{keyword}{const} \textcolor{keyword}{auto} type = av::MediaType::Audio;}
\DoxyCodeLine{00101 }
\DoxyCodeLine{00102     \textcolor{keywordflow}{if} (managed\_types\_[type]) throwError(\textcolor{stringliteral}{"{}audio pipeline already inited"{}});}
\DoxyCodeLine{00103     managed\_types\_[type] = \textcolor{keyword}{true};}
\DoxyCodeLine{00104 }
\DoxyCodeLine{00105     \textcolor{comment}{/* Init decoder */}}
\DoxyCodeLine{00106     decoders\_[type] = \mbox{\hyperlink{classDecoder}{Decoder}}(demuxer.\mbox{\hyperlink{classDemuxer_a21dcade74fec8cb4a30e312c79dd1274}{getStreamParams}}(type));}
\DoxyCodeLine{00107 }
\DoxyCodeLine{00108     \textcolor{keyword}{auto} dec\_ctx = decoders\_[type].getContext();}
\DoxyCodeLine{00109     uint64\_t channel\_layout;}
\DoxyCodeLine{00110     \textcolor{keywordflow}{if} (dec\_ctx-\/>channel\_layout) \{}
\DoxyCodeLine{00111         channel\_layout = dec\_ctx-\/>channel\_layout;}
\DoxyCodeLine{00112     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00113         channel\_layout = av\_get\_default\_channel\_layout(dec\_ctx-\/>channels);}
\DoxyCodeLine{00114     \}}
\DoxyCodeLine{00115 }
\DoxyCodeLine{00116     \textcolor{comment}{/* Init encoder */}}
\DoxyCodeLine{00117     encoders\_[type] = \mbox{\hyperlink{classEncoder}{Encoder}}(codec\_id, dec\_ctx-\/>sample\_rate, channel\_layout, muxer\_-\/>getGlobalHeaderFlags(),}
\DoxyCodeLine{00118                               std::map<std::string, std::string>());}
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120     \textcolor{comment}{/* Init converter */}}
\DoxyCodeLine{00121     converters\_[type] =}
\DoxyCodeLine{00122         \mbox{\hyperlink{classConverter}{Converter}}(decoders\_[type].getContext(), encoders\_[type].getContext(), demuxer.\mbox{\hyperlink{classDemuxer_a5465f2d641af3ddfb253ff2cbd87ba37}{getStreamTimeBase}}(type));}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124     muxer\_-\/>addStream(encoders\_[type].getContext());}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126     \textcolor{keywordflow}{if} (async\_) startProcessor(type);}
\DoxyCodeLine{00127 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classPipeline_abdb81129dd9b6fc8b6db16ecba3c0a98}\label{classPipeline_abdb81129dd9b6fc8b6db16ecba3c0a98}} 
\index{Pipeline@{Pipeline}!initVideo@{initVideo}}
\index{initVideo@{initVideo}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{initVideo()}{initVideo()}}
{\footnotesize\ttfamily void Pipeline\+::init\+Video (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classDemuxer}{Demuxer}} \&}]{demuxer,  }\item[{AVCodec\+ID}]{codec\+\_\+id,  }\item[{AVPixel\+Format}]{pix\+\_\+fmt,  }\item[{const \mbox{\hyperlink{classVideoParameters}{Video\+Parameters}} \&}]{video\+\_\+params }\end{DoxyParamCaption})}

Initialize the video processing, by creating the corresponding decoder, converter and encoder 
\begin{DoxyParams}{Parameters}
{\em demuxer} & the demuxer containing the input stream of packets \\
\hline
{\em codec\+\_\+id} & the ID of the codec to use for the output video \\
\hline
{\em pix\+\_\+fmt} & the pixel format to use for the output video \\
\hline
{\em video\+\_\+params} & the parameters to use for the output video \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00062}{62}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00063                                                               \{}
\DoxyCodeLine{00064     \textcolor{keyword}{const} \textcolor{keyword}{auto} type = av::MediaType::Video;}
\DoxyCodeLine{00065 }
\DoxyCodeLine{00066     \textcolor{keywordflow}{if} (managed\_types\_[type]) throwError(\textcolor{stringliteral}{"{}video pipeline already inited"{}});}
\DoxyCodeLine{00067     managed\_types\_[type] = \textcolor{keyword}{true};}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069     \textcolor{comment}{/* Init decoder */}}
\DoxyCodeLine{00070     decoders\_[type] = \mbox{\hyperlink{classDecoder}{Decoder}}(demuxer.\mbox{\hyperlink{classDemuxer_a21dcade74fec8cb4a30e312c79dd1274}{getStreamParams}}(type));}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072     \textcolor{keyword}{auto} dec\_ctx = decoders\_[type].getContext();}
\DoxyCodeLine{00073     \textcolor{keyword}{auto} [width, height] = video\_params.getVideoSize();}
\DoxyCodeLine{00074     \textcolor{keyword}{auto} [offset\_x, offset\_y] = video\_params.getVideoOffset();}
\DoxyCodeLine{00075     \textcolor{keywordflow}{if} (!width) width = dec\_ctx-\/>width;}
\DoxyCodeLine{00076     \textcolor{keywordflow}{if} (!height) height = dec\_ctx-\/>height;}
\DoxyCodeLine{00077     \textcolor{keywordflow}{if} (offset\_x + width > dec\_ctx-\/>width) throwError(\textcolor{stringliteral}{"{}Output video width exceeds input one"{}});}
\DoxyCodeLine{00078     \textcolor{keywordflow}{if} (offset\_y + height > dec\_ctx-\/>height) throwError(\textcolor{stringliteral}{"{}Output video height exceeds input one"{}});}
\DoxyCodeLine{00079 }
\DoxyCodeLine{00080     \textcolor{comment}{/* Init encoder */}}
\DoxyCodeLine{00081     std::map<std::string, std::string> enc\_options;}
\DoxyCodeLine{00082     \textcolor{comment}{/*}}
\DoxyCodeLine{00083 \textcolor{comment}{     * Possible presets from fastest (and worst quality) to slowest (and best quality):}}
\DoxyCodeLine{00084 \textcolor{comment}{     * ultrafast -\/> superfast -\/> veryfast -\/> faster -\/> fast -\/> medium}}
\DoxyCodeLine{00085 \textcolor{comment}{     */}}
\DoxyCodeLine{00086     enc\_options.insert(\{\textcolor{stringliteral}{"{}preset"{}}, \textcolor{stringliteral}{"{}ultrafast"{}}\});}
\DoxyCodeLine{00087     encoders\_[type] = \mbox{\hyperlink{classEncoder}{Encoder}}(codec\_id, width, height, pix\_fmt, demuxer.\mbox{\hyperlink{classDemuxer_a5465f2d641af3ddfb253ff2cbd87ba37}{getStreamTimeBase}}(type),}
\DoxyCodeLine{00088                               muxer\_-\/>getGlobalHeaderFlags(), enc\_options);}
\DoxyCodeLine{00089 }
\DoxyCodeLine{00090     \textcolor{comment}{/* Init converter */}}
\DoxyCodeLine{00091     converters\_[type] = \mbox{\hyperlink{classConverter}{Converter}}(decoders\_[type].getContext(), encoders\_[type].getContext(),}
\DoxyCodeLine{00092                                   demuxer.\mbox{\hyperlink{classDemuxer_a5465f2d641af3ddfb253ff2cbd87ba37}{getStreamTimeBase}}(type), offset\_x, offset\_y);}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     muxer\_-\/>addStream(encoders\_[type].getContext());}
\DoxyCodeLine{00095 }
\DoxyCodeLine{00096     \textcolor{keywordflow}{if} (async\_) startProcessor(type);}
\DoxyCodeLine{00097 \}}

\end{DoxyCode}
\mbox{\Hypertarget{classPipeline_a219c911a44e34564f4a0fbe28e049412}\label{classPipeline_a219c911a44e34564f4a0fbe28e049412}} 
\index{Pipeline@{Pipeline}!printInfo@{printInfo}}
\index{printInfo@{printInfo}!Pipeline@{Pipeline}}
\doxysubsubsection{\texorpdfstring{printInfo()}{printInfo()}}
{\footnotesize\ttfamily void Pipeline\+::print\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Print the informations about the internal demuxer, decoders and encoders 

Definition at line \mbox{\hyperlink{pipeline_8cpp_source_l00206}{206}} of file \mbox{\hyperlink{pipeline_8cpp_source}{pipeline.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00206                                \{}
\DoxyCodeLine{00207     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} type : av::validMediaTypes) \{}
\DoxyCodeLine{00208         \textcolor{keywordflow}{if} (managed\_types\_[type]) \{}
\DoxyCodeLine{00209             std::cout << \textcolor{stringliteral}{"{}Decoder "{}} << type << \textcolor{stringliteral}{"{}: "{}} << decoders\_[type].getName() << std::endl;}
\DoxyCodeLine{00210             std::cout << \textcolor{stringliteral}{"{}Encoder "{}} << type << \textcolor{stringliteral}{"{}: "{}} << encoders\_[type].getName() << std::endl;}
\DoxyCodeLine{00211         \}}
\DoxyCodeLine{00212     \}}
\DoxyCodeLine{00213 \}}

\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/process/pipeline.\+h\item 
src/process/pipeline.\+cpp\end{DoxyCompactItemize}
